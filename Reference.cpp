// 레퍼런스
/*
	C++에서 제공하는 레퍼런스를 사용하면 기존 변수에 새 이름을 지정할 수 있다.

		int x = 42;
		int& xReference = x;

	변수의 타입 뒤에 &를 붙이면 그 변수는 레퍼런스가 된다.
	코드를 다루는 방법은 일반 변수와 같지만 내부적으로는 원본 변수에 대한 포인터로 취급한다.
	둘 중 한 변수에서 값을 변경하면 그 결과가 다른 변수에도 반영된다.

	## 1. 레퍼런스 전달 방식

	일반적으로 함수에 전달한 변수는 값 전달 방식(pass by value)으로 처리한다.
	변수를 가리키는 포인터를 역참조하면 그 포인터가
	현재 스택 프레임을 가리키지 않더라도 함수 안에서 그 변수가 가리키는 메모리의 값을 수정할 수 있다.
	그런데 이 방식은 포인터 연산이 많아져서 간단한 작업이더라도 코드가 복잡해진다.
	C++에서는 레퍼런스 전달 방식(pass by referece)을 제공한다.
	이 방식을 사용하면 매개변수가 포인터값이 아닌 레퍼런스로 전달된다.

		void addOne(int& i) { i++; }

	복제하는 데 부담스러울 정도로 큰 구조체나 클래스를 리턴하는 함수를 구현할 때는
	구조체나 클래스를 non-const 레퍼런스로 받아서 원하는 작업을 수행한 뒤
	그 결괄ㄹ 직접 리턴하지 않고 내부에서 곧바로 수정하는 방식을 많이 사용한다.
	함수에서 구조체나 클래스를 복제함으로써 발생하는
	성능 저하를 최소화하기 위해 오래전부터 사용하던 방식이다.
	하지만 C++11부터 추가된 이동 의미론(무브 시맨틱스 move semantics) 덕분에 복제하지 않고도
	구조체나 클래스를 직접 리턴할 수 있다. (이동 의미론은 9장에서 설명)

	## 2. const 레퍼런스 전달 방식

	const 레퍼런스의 가장 큰 장점은 성능이다.
	레퍼런스로 전달하면 원본에 대한 포인터만 전달되기 때문에 원본 전체를 복제할 필요가 없다.
	또한 const 레퍼런스로 전달하면 복제되지도 않고 원본 변수가 변경되지도 않는 장점을 모두 취할 수 있다.
	const 레퍼런스는 특히 객체를 다룰 때 유용하다.
	객체는 대체로 커서 복제하는 동안 의도하지 않은 효과가 발생할 수 있기 때문이다.

		void printString(const std::string& myString) {}

*/