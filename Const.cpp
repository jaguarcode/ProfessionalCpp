// const의 다양한 용도
// const 상수
/*
	C 언어에서는 흔히 버전 번호처럼 프로그램을 실행하는 동안 변경하면 안되는 값에
	이름을 붙일 때는 전처리 구문인 #define을 사용했다.
	C++에서는 상수를 #define 대신 const로 정의하는 것이 바람직하다.

	const로 상수를 정의하는 방법은 변수를 정의할 때와 거의 같고,
	값이 변경되지 않도록 보장하는 작업은 컴파일러가 처리한다는 점만 다르다.

	(#define은 전처리기가 처리하고, const는 컴파일러가 처리한다.
	define 문은 코드를 메타 수준으로 처리해서 언어의 구문과 의미에 대해 신경쓰지 않고
	단순히 텍스트 매칭 작업을 수행한다. 반면 const는 메타 수준이 아닌 C++ 코드 문맥 안에서 컴파일러가 평가한다.
	그래서 const로 정의할 대상에 타입이나 스코프를 적용할 수 있다는 장점이 있다.)

		const int versionNumberMajor = 2;
		const int versionNumberMinor = 1;
		const std::string productName = "Super Hyper Net Modulator";
*/

// const 매개변수
/*
	C++에서는 non-const 변수를 const 변수로 캐스팅할 수 있다.
	매개변수를 const로 작성한 함수 안에서 매개변수의 값을 변경하면 컴파일 오류가 발생한다.
	이런 제약사항을 피하는 여러 방법이 있지만,
	구현할 때 특별히 주의를 기울여야 한다.
	C++에서는 const 변수를 실수로 변경하는 경우만 보호해준다.
*/

// 레퍼런스
/*
	C++에서 제공하는 레퍼런스를 사용하면 기존 변수에 새 이름을 지정할 수 있다.
		
		int x = 42;
		int& xReference = x;

	변수의 타입 뒤에 &를 붙이면 그 변수는 레퍼런스가 된다.
	코드를 다루는 방법은 일반 변수와 같지만 내부적으로는 원본 변수에 대한 포인터로 취급한다.
	둘 중 한 변수에서 값을 변경하면 그 결과가 다른 변수에도 반영된다.

	## 1. 레퍼런스 전달 방식

	일반적으로 함수에 전달한 변수는 값 전달 방식(pass by value)으로 처리한다.
	변수를 가리키는 포인터를 역참조하면 그 포인터가 
	현재 스택 프레임을 가리키지 않더라도 함수 안에서 그 변수가 가리키는 메모리의 값을 수정할 수 있다.
	그런데 이 방식은 포인터 연산이 많아져서 간단한 작업이더라도 코드가 복잡해진다.
	C++에서는 레퍼런스 전달 방식(pass by referece)을 제공한다.
	이 방식을 사용하면 매개변수가 포인터값이 아닌 레퍼런스로 전달된다.

		void addOne(int& i) { i++; }

	복제하는 데 부담스러울 정도로 큰 구조체나 클래스를 리턴하는 함수를 구현할 때는 
	구조체나 클래스를 non-const 레퍼런스로 받아서 원하는 작업을 수행한 뒤 
	그 결괄ㄹ 직접 리턴하지 않고 내부에서 곧바로 수정하는 방식을 많이 사용한다.
	함수에서 구조체나 클래스를 복제함으로써 발생하는 
	성능 저하를 최소화하기 위해 오래전부터 사용하던 방식이다.
	하지만 C++11부터 추가된 이동 의미론(무브 시맨틱스 move semantics) 덕분에 복제하지 않고도
	구조체나 클래스를 직접 리턴할 수 있다. (이동 의미론은 9장에서 설명)

	## 2. const 레퍼런스 전달 방식

	const 레퍼런스의 가장 큰 장점은 성능이다.
	레퍼런스로 전달하면 원본에 대한 포인터만 전달되기 때문에 원본 전체를 복제할 필요가 없다.
	또한 const 레퍼런스로 전달하면 복제되지도 않고 원본 변수가 변경되지도 않는 장점을 모두 취할 수 있다.
	const 레퍼런스는 특히 객체를 다룰 때 유용하다.
	객체는 대체로 커서 복제하는 동안 의도하지 않은 효과가 발생할 수 있기 때문이다.

		void printString(const std::string& myString) {}

*/